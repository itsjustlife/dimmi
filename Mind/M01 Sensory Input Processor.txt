Module M01: Sensory Input Processor

---
Module: M01_Sensory_Input_Processor
Version: 1.0
Purpose: Ingest and preprocess raw input (e.g., user message) for downstream modules
Triggers: [ "New_User_Input" ]
Inputs: [ "Raw user text or data stream" ]
Outputs: [ "Cleaned_Text", "Parsed_Input_Structure" ]
Dependencies: [ ]
Safety_Level: Low
Checksum: 3c7f0e45e098f6f8c0d14dcb9d8b6efd
---

PURPOSE:
 The Sensory Input Processor module acts as the system’s “sensory organs.” Its purpose is to receive raw input from the user (or other sources) and convert it into a standardized, structured format for the rest of the system to work with. This includes basic cleaning (trimming whitespace, removing unsupported characters), validation (ensuring the input is not empty or overly long), and simple parsing if needed. By handling low-level input processing here, downstream modules can assume they’re working with well-formed input. This improves overall robustness and prevents repeated preprocessing in multiple modules.

INPUTS:
 - Raw user text (e.g., a chat message, command, or query in plain text).
 - (Optionally) Other forms of data if extended (like audio transcripts, after voice-to-text, or image descriptions after an OCR step), though initially it’s plain text.
 
OUTPUTS:
 - **Cleaned_Text:** A sanitized string of the user’s input text (trimmed, normalized encoding).
 - **Parsed_Input_Structure:** A structured representation (if applicable) such as a JSON with fields like “type” (question/command), “content” (text), etc., or simply the same text if no further parsing is needed. This structure will be consumed by the Language Comprehension module.

DETAILED_DECISION_LOGIC:
 1. **Receive Input**: On trigger (new user input), capture the raw input string as `raw_input`.
 2. **Basic Validation**: If `raw_input` is empty or null, output an error message structure or a special flag (since there's nothing to process) and terminate this cycle. Also, if `raw_input` exceeds a predefined length (to avoid extremely long inputs causing issues), truncate or flag it for handling (this threshold can be adjusted in change instructions).
 3. **Cleaning**: 
    - Remove any leading/trailing whitespace or line breaks from `raw_input`.
    - Normalize encoding (e.g., ensure it’s in UTF-8 and remove or replace any non-printable characters).
    - If there are any disallowed control sequences or obvious prompt-injection patterns (like `<!--` or unusual tokens), either escape them or flag them for the Safety module. *Note:* Detailed malicious pattern checks are mainly done by Safety (M11), but basic input sanitization is done here as a first line of defense.
 4. **Identify Input Type (Optional)**: If the system distinguishes types of inputs (question vs. command vs. other), attempt a lightweight classification:
    - For example, if `raw_input` matches certain regex or keywords (e.g., starts with "Calculate" or "#!"), mark it as a special command type.
    - Otherwise, default type is "user_message".
    This classification logic can be simple or expanded as needed (and updated via change instructions).
 5. **Parse into Structure**: Create a data structure `parsed_input`:
    - Set `parsed_input.text = cleaned_text` (the cleaned raw input).
    - Set `parsed_input.type = identified_type` (e.g., "question", "command", etc., or "unknown" if not determined).
    - Include any other metadata if relevant (timestamp, source, etc., though for a user chat, source is usually user).
    If no complex structure is needed, the module can simply pass along the cleaned text as output.
 6. **Output Results**: Provide the cleaned text and parsed structure to the next module:
    - Cleaned_Text output is a string (e.g., "  Hello world!  " -> "Hello world!").
    - Parsed_Input_Structure output could be a dictionary or object like: `{ "type": "user_message", "content": "Hello world!" }`.
    These outputs are now ready for the Language Comprehension module (M02) to consume.

RECURSION_CHECKS:
 - The Input Processor does not call any other module; it’s a leaf at the start of the pipeline. Thus, there is no internal recursion. 
 - It ensures not to re-trigger itself: once it produces output for a given input, it won’t feed that output back as new input (that’s handled by the orchestrator of the system).
 - If an input is flagged as invalid (empty or too long), it outputs a flag but does not attempt to re-process it in a loop (avoiding infinite retry cycles).

CHANGE_INSTRUCTIONS:
 - **Adjust input length limit**: To change the maximum allowed input length, find the check in step 2 where the input is compared to a threshold. Modify that threshold value (e.g., from 5000 characters to 10000 characters) as needed.
 - **Extend type classification**: If new types of inputs need special handling (e.g., image URLs, or a voice note indicator), update step 4. Add new conditions or regexes to detect those, and assign an appropriate `parsed_input.type`. Also update the Outputs description if new types are introduced.
 - **Modify cleaning rules**: To add or remove cleaning steps (for example, to allow certain markup or to strip HTML tags if you plan to input HTML), edit step 3 accordingly. Ensure any new cleaning operation is reflected in both the logic and the description above for clarity.
 - **Integration with Safety**: If you want this module to do more aggressive safety filtering (rather than deferring to M11), you could insert a sub-step in step 3 to scan for certain keywords. Be cautious: duplicating too much safety logic here can lead to maintenance burden. It’s usually better to let M11 handle content filtering. If you do add such checks, document them and possibly note in M11’s dependencies that M01 does some pre-filtering.
 - After making changes, update the **Version** number at the top of the file (e.g., to 1.1) and recompute the **Checksum** for the file’s new content.

---
Next_Suggest: M02_Language_Comprehension
Alternate_Next: (None)
Resource_Usage: Low (simple string operations, negligible performance impact)
---