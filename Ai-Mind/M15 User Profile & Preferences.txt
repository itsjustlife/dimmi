Module M15: User Profile & Preferences Module

---
Module: M15_User_Profile
Version: 1.0
Purpose: Store and provide user-specific information and preferences to personalize the AI's behavior
Triggers: [ "Profile_Query", "Profile_Update" ]
Inputs: [ "Requested_Info_Type", "New_User_Data" ]
Outputs: [ "User_Info_Data", "Confirmation_Update" ]
Dependencies: [ "M04_Long_Term_Memory" ]
Safety_Level: Low
Checksum: dcb636a99f1993b0293d945ea219ff6b
---

PURPOSE:
 The User Profile & Preferences Module holds data about the user that the AI has learned or that was provided, allowing the AI to tailor its responses and actions accordingly. This might include the user’s name, preferred pronouns, formality level, any domain-specific knowledge about the user (like their job role if relevant, past questions they've asked, their skill level, etc.), and any persistent preferences (such as "always provide sources in answers" or "speak in simple language"). By centralizing this info, whenever another module (like M14 for tone or M07 for planning relevant to user context) needs user-specific context, it can query M15. It’s analogous to a personal assistant remembering details about the person it assists.

INPUTS:
 - **Requested_Info_Type (Profile_Query):** A query from another module about specific user info. For example:
   - "name" -> asking for user's name.
   - "tone_preference" -> asking how formal/informal to be.
   - "knowledge_level_topicX" -> maybe how much the user likely knows about topic X to adjust explanation depth.
   - If no specific type, a module might just query for "preferences" and get a summary.
   - The query could also be triggered at conversation start to load all relevant profile data into context.
 - **New_User_Data (Profile_Update):** Information to store or update in the profile. This can come from:
   - The user providing information ("My name is Alice", "I'm a doctor", "I prefer short answers").
   - Deductions by the AI (though be careful with that, perhaps better to have confirmed info).
   - It could be structured (like key: value) or freeform text that M15 will parse.
   - For example, an input could be `{key: "name", value: "Alice"}` or a more complex preference object.

OUTPUTS:
 - **User_Info_Data:** The data requested by a query:
   - If it's a simple field like name or language, output that value.
   - If it's a composite preference, output the relevant details (e.g., "tone: casual, detail_level: low").
   - If the data isn't known, output a null or a default (for instance, if no preference set for tone, default could be 'neutral' or rely on general settings).
   - If the query requested a summary of profile, output a brief summary of all key preferences known.
 - **Confirmation_Update:** When updating, confirm or acknowledge that:
   - The data has been stored or updated. Could be as simple as a boolean or message.
   - This might not always be used by other modules, but if user or system needs to know the profile was updated successfully, this output can be consumed by communication (like M14 might tell user "Noted, I'll remember that you prefer short answers.").
   - If the update is invalid or raises a conflict (rare unless format wrong or it's something disallowed, but profile data is generally safe), output an error status instead.
 - The profile data itself might be stored within this module (in memory) and/or persisted via M04 (Long-Term Memory) for retrieval in future sessions. Since our architecture resets each run, if persistence is needed beyond one session, hooking to M04 to save would be necessary.
   - Possibly M15 on start could pull data from M04 if available (that might be a design: M04 as backing store, M15 as cache). But let's assume here a single session, or if multi-session, M15 does use M04 for recall.

DETAILED_DECISION_LOGIC:
 1. **Handle Profile Query**:
    - Receive a request for specific user info or preferences.
    - If the module has that info stored internally (perhaps in a dictionary or set of variables), retrieve it.
    - If not stored internally, and if long-term memory (M04) integration is set, query M04 for that info:
      - e.g., search by key or a tag like "UserProfile:<userID>:<key>" if such convention. But likely simpler: at session start, M15 would have loaded M04 data already.
    - If found, prepare it in appropriate format for the requester:
      - Some modules might want raw value (like name as a string for greeting).
      - Some might want it in a sentence or context (like M14 might incorporate name in a sentence).
      - Usually raw value is fine and the module can decide how to use it.
    - If not found:
      - Decide on a default or say "unknown".
      - E.g., if tone preference not known, maybe output "neutral" as default.
      - If name not known, output None or an empty string (meaning don't use a name).
      - If knowledge level unknown, possibly assume moderate.
    - Output User_Info_Data with the answer.
    - (If it’s a summary request, compile known key-values into a short form).
 2. **Handle Profile Update**:
    - Receive new user data to store.
    - Validate the data:
      - Check if key is recognized (like "name", "language", "pref_tone" etc.). If not recognized, you might still store it as custom but then other modules might not use it. Alternatively, ignore unknown keys or set a generic note.
      - Check if the value is plausible/allowed. Usually profile info is benign, but ensure e.g., it's not ridiculously long (to avoid someone injecting huge text into memory). Possibly clamp length or irrelevant content.
      - Safety isn't a big concern here since it's user-provided personal data. But if user says something disallowed about themselves? Unlikely scenario, but e.g., if user profile had sensitive info, storing it is fine, but ensure it isn't accidentally output later without caution (that’s M11's job though when output).
    - Store the data:
      - Internally update the profile dictionary.
      - Also possibly push to M04 for persistence. For example, call M04 with "store: UserProfile.key=value".
      - Ensure not to duplicate entries in M04 (if there's an old value, maybe remove it or mark outdated).
      - If multi-session memory is not needed, internal storage suffices for session.
    - Output Confirmation_Update:
      - Could be just a success flag `true` or a message "Profile updated".
      - If the user explicitly gave this info and might expect acknowledgment, M14 could use this output to confirm to user. Or M15 might directly prompt M14 to generate a confirmation like "Alright, I'll remember that." But that would be done by M09/M14 in the dialogue logic typically.
      - For internal update via interface, just success code is enough.
 3. **Integration with Other Modules**:
    - M15 should make it easy for modules like M14 or M07 to access what they need without burden.
    - Possibly, at conversation start, M02 or orchestrator might call M15 to fetch a baseline user profile (like default name, etc.) to use during the session.
    - If user says "call me X", then after updating, M15 might want to push that knowledge to short-term memory (M03) as well if immediate greeting is to be used, but likely not necessary since next time name is needed, M14 will query M15 and get it.
    - Ensure that dependencies and triggers are set so that a profile query doesn't stall waiting for something. It's straightforward look-up.
 4. **Data Scope and Reset**:
    - If there's an ID or way to differentiate users, M15 would use that to separate profiles (not covered but implied).
    - On session end, data might be saved to M04 if persistent, but ephemeral data might be lost. M15 possibly on initialization triggers a load from M04.
    - Not in dynamic logic, but as design: consider how persistent the profile is needed beyond one run. For now, treat as persistent for within session; if needed across sessions, rely on M04 or external storage on disk.
 
RECURSION_CHECKS:
 - M15 should not cause heavy loops. It might call M04 which is quick database like usage, not causing cognitive loop.
 - When updating profile, if it also tries to update long-term memory which triggers M12 reflection on memory change? Unlikely. M04 storing should be straightforward.
 - No self-calls or interdependent triggers likely. Modules request info and move on.
 - Avoid an update triggering a query immediately (unless some orchestrator logic re-queries to confirm, but no need).
 
CHANGE_INSTRUCTIONS:
 - **Expand stored attributes**: If new user-specific data becomes relevant (e.g., context of previous interactions, or a record of user's expertise in various topics), add those as recognized keys and use them.
   - E.g., store a list of user’s favorite topics to tailor examples or analogies.
   - This may require also adjusting how other modules use it.
 - **Privacy controls**: If needed, incorporate flags for data that should not be output without permission. Possibly mark some profile entries as "sensitive". M11 would anyway catch if something like an address is about to be blurted out, but having a marker might proactively warn M14 to ask "should I include this?" (advanced, not implemented now).
 - **Deletion/Reset**: Provide a way to clear profile if user asks "forget my preferences" or under a new user context. Implementation could listen for a special command to wipe profile (clear memory and relevant M04 entries).
 - **Multi-user or ID handling**: If this system had multiple user profiles, incorporate a user ID in queries/updates to know which profile to manage. Possibly out-of-scope here, but if needed, adapt storage access accordingly.
 - **Integration with authentication**: If user identity can be confirmed (like user logs in), M15 might link to that. But likely beyond our immediate scope. Just mention if needed that M15 could integrate with an external user account DB.
 - After adjustments, update **Version** and **Checksum**. Ensure to also update any part of system that queries it if keys changed (like if you rename "pref_tone" to "style_tone", update M14 query accordingly).

---
Next_Suggest: (None – serves on-demand)
Alternate_Next: (None)
Resource_Usage: Low (simple data storage and retrieval)
---
