Module M16: Environment Context Module

---
Module: M16_Environment_Context
Version: 1.0
Purpose: Provide information about the external environment or system context to the AI for situational awareness
Triggers: [ "Environment_Query", "Environment_Update_Event" ]
Inputs: [ "Requested_Environment_Info", "New_Env_Data" ]
Outputs: [ "Environment_Info", "Env_Update_Confirmation" ]
Dependencies: [ ]
Safety_Level: Low
Checksum: 9e4939a88a8ffc68c2073b2f4db0a1f3
---

PURPOSE:
 The Environment Context Module supplies non-user-specific context about the situation or platform in which the AI is operating. This can include data like the current date and time, the AI’s system status, location (if relevant and allowed), available tools or resources, or any environmental conditions that might affect responses. Essentially, it's how the AI knows "what’s going on around it" beyond the user’s words. For instance, if the AI should know the date to answer "what day is it?" or if certain functions are offline, M16 would provide that info. It's analogous to human senses or awareness of surroundings, but for the AI's digital environment.

INPUTS:
 - **Requested_Environment_Info (Environment_Query):** A query from another module about some environmental parameter. Examples:
   - "current_date" or "current_time" for time queries.
   - "available_tools" to know what tools or plugins the AI currently can use.
   - "system_status" if, say, the AI should know if it's online/offline with respect to Internet or if a resource is reachable.
   - "location" if the AI is tied to a specific location (maybe for IoT or robotics contexts, though in a pure chatbot might not apply unless location-based info).
   - Essentially any external state needed for decision or answer.
 - **New_Env_Data (Environment_Update_Event):** Notification of a change in environment or an update to context.
   - e.g., if the system time changed significantly (like daylight savings or time zone change), or if a new tool became available or one got revoked mid-run (like losing internet connectivity).
   - Or perhaps an admin can send an update like "system entering maintenance mode".
   - This allows M16 to update its records so that queries reflect the new state.
   - It could also include periodic updates (like tick triggers to update time each minute, but more efficient is just query time when needed rather than event every minute).
   - Another example: if the AI is part of a larger system with sensors, an update might be "temperature=75F".
   - We'll assume minimal usage in chatbot context aside from time and maybe capabilities.

OUTPUTS:
 - **Environment_Info:** The information requested by a query.
   - If "current_date", output in a standard format or as a date object if system supports.
   - If "current_time", similarly.
   - If "system_status", maybe a short text like "Online" or "No internet".
   - If "available_tools", perhaps a list of tool names or descriptions that M10 can call (which M07 or M09 might use to plan).
   - If something isn't available or applicable (like an unknown query), respond with null or "unknown".
   - Keep the output straightforward (since likely the consumer just needs the data).
   - Possibly format for user if the consumer is directly M14 wanting to tell the user (though M14 could format it, raw data is fine).
 - **Env_Update_Confirmation:** If an environment update event is processed:
   - Confirm that the new data was recorded.
   - Could be a simple "ack" or echo of the new state.
   - Or if the update triggered some cascade (like adjusting some internal config), confirm that too.
   - This might be used by the orchestrator or not at all if not needed explicitly.

DETAILED_DECISION_LOGIC:
 1. **Handle Environment Query**:
    - Identify what info is being requested (by key or type).
    - For dynamic data like time:
      - Fetch the current system time. (The module likely has access to a clock.)
      - For date/time, if needed in user terms, decide format (like "Wednesday, June 04, 2025 at 02:54:13 AM" as in system message above). Possibly a shorter format if being passed to another module which will do formatting.
      - Output as a string or structured if needed. Likely a nicely formatted string is fine, but the decision might depend on usage.
    - For static or semi-static environment info:
      - If it's stored internally (like if at start, M16 captured environment info e.g., version number of AI, or location if set), retrieve that.
      - If not stored, see if it can be derived or is hardcoded.
      - For example, "available_tools" could be coded as a list of actions M10 can do (like ["web_search", "calc", ...]).
      - If location or others not applicable, either return "not available" or coordinate with profile if maybe user location stored in profile instead. But environment in our context mostly system stuff.
    - If query is unknown, return something like "unknown query".
    - Provide **Environment_Info** output.
 2. **Handle Environment Update Event**:
    - Receive new environment data (key and value).
    - Validate if needed:
      - e.g., if time zone changed, ensure format correct.
      - If an unexpected key, decide to store it generically or ignore.
    - Update internal state:
      - E.g., update a dictionary of env values.
      - If the data is something like "internet_connection": false, store that to later answer system_status queries.
      - If repetitive (like continuous sensor feed), maybe store last value or average as needed (though our design likely doesn't handle high-frequency data).
    - Possibly if critical, alert some modules:
      - For instance, if internet goes off, M10 or M09 might need to know to not attempt web searches. M16 could proactively notify them (maybe through the same event trigger concept or via orchestrator making a global state).
      - But simpler is that M09 queries M16 "system_status" before using tools.
      - So proactive alerting might not be necessary unless it's a major context shift (like switching modes).
    - Output **Env_Update_Confirmation** (just a success note).
 3. **Integration**:
    - M07 (Planner) might query "available_tools" at planning time to decide if it can plan an internet search or not. M16 should return correct list.
    - M09 might query "system_status" if a plan step fails to see if maybe internet is down etc.
    - M14 rarely needs environment except maybe time if user asked for time.
    - M02 could use environment if user’s question is explicitly environment related ("what time is it?" or "are you online?").
    - In such cases, M02 might even directly answer or M02 might output an intent "ask_time" and M06/M09 route to M16.
    - Possibly skip complexity: easier is M02 doesn't know time but knows to ask environment: So M09 upon a user question like "what time is it?" recognizes it as needing env info and queries M16, then M14 responds.
    - That logic would be implemented in M09 or M07 by pattern or via a function call in code. If we had function calling, M16 would be registered as a function for "get_time".
    - But in our architecture, since we can orchestrate, we'll say the question triggers M09 to query M16 before reasoning if needed.
    - M16 thus should be robust to be called at any time quickly.
 4. **Default Data**:
    - At initialization, M16 might set some default env info:
      - E.g., it could record the start time of session (to answer how long it's been running if needed).
      - Or load config like which tools allowed.
      - If any environment variables or config files, it could load those.
    - This isn't triggered but rather a start-up routine (maybe orchestrator calls an init function).
    - We can mention such in comments if needed (like reading a config of available tools).
 
RECURSION_CHECKS:
 - M16 is mostly passive data provider. It shouldn't call other cognitive modules, except maybe M04 if we considered environment persistence (like remembering last known internet status from previous run).
 - But typically environment resets, so it's fine.
 - No loops; answering a query is one-off.
 - Ensure time queries don't inadvertently trigger themselves (not an issue unless we did something weird like environment query asking environment query).
 - If integrated with system events, careful to not flood system with updates (like a loop of environment->update->some reaction->update again; not applicable unless miswired).
 
CHANGE_INSTRUCTIONS:
 - **Extend environment data**: If you want to track more context (like if integrated with hardware: battery level, or external conditions like weather from an API, etc.), add keys and logic to retrieve them either on query or periodic updates.
   - E.g., add "weather" key which when asked triggers a quick API call. That could be done via M10 actually since that's a tool usage. Alternatively, environment might hold last fetched weather if it auto-updates periodically.
   - But going out to internet spontaneously is not safe here; better to treat that as a tool via M10 triggered by planning, not as environment static info.
   - So environment mostly contains static or local info, not external info requiring active calls (barring time).
 - **Persistence**: If environment context should persist across sessions (maybe not required except config values), consider using M04. For example, if the AI has modes (like "expert mode on/off") that could be environment or profile depending on how you see it, and should persist, store in long-term memory and retrieve on start.
 - **Time zone and format**: Adapt time outputs if needed. The example format given in system message is quite detailed with timezone. If you want shorter output (like "02:54 AM, June 04, 2025 PST"), format accordingly.
   - Possibly adapt to user location if known (user in different time zone). That would require knowing user’s zone from profile, and converting. Not currently implemented but could be if needed: when user asks time, you might guess they mean their local time. Without location, probably give system time or UTC.
 - **Dynamic tool availability**: If at runtime tools get enabled/disabled, ensure that update event triggers adjustments. Or simpler, if fixed per session, define at start and don't change.
 - **System status**: If we wanted more granular (like CPU load or memory usage), could add though likely irrelevant to user or operation unless you have self-optimization. Usually not needed in a chatbot context.
 - After changes, update **Version** and **Checksum**. Communicate any changes to how modules should query if needed.

---
Next_Suggest: (None – on-demand utility module)
Alternate_Next: (None)
Resource_Usage: Low (simple queries, maybe system calls for time; negligible)
---