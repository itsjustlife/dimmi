Module M09: Decision Engine Module

---
Module: M09_Decision_Engine
Version: 1.0
Purpose: Select the next action or response based on current plans, reasoning outputs, and context
Triggers: [ "Plan_Available", "Inference_Ready", "Action_Feedback" ]
Inputs: [ "Plan_Steps from M07", "Inference_Result from M08", "External_Action_Result" ]
Outputs: [ "Chosen_Action", "Next_Step_Command", "Completion_Status" ]
Dependencies: [ "M10_Action_Execution", "M08_Reasoning", "M11_Safety_Alignment", "M14_Communication" ]
Safety_Level: High
Checksum: 937a6006c3da7033104d2f1fc8b2330f
---

PURPOSE:
 The Decision Engine is the control unit that decides **what to do next** at each point in the process. It uses the plan (if one exists) from M07 as a guide and the results from M08’s reasoning to inform its choices. Essentially, M09 sits in the loop of execution: it picks a step from the plan (or determines the single action to take if no multi-step plan), decides whether to execute an external action (via M10), call the reasoning module (M08) for more analysis, or produce an answer to the user (via M14). This is analogous to a human’s executive function in the brain: given an objective and some information, it chooses to either gather more info, perform an action, or conclude and respond.

INPUTS:
 - **Plan_Steps:** The list of steps output by the Planning module (M07). If a multi-step plan is in play, M09 references this to know the sequence of actions.
 - **Inference_Result:** Outputs from the Reasoning module (M08). Often, M09 requests M08 to handle a step that requires thinking, and once it gets the result, it decides how to use that result (e.g., feed it into the next step or directly respond).
 - **External_Action_Result:** The outcome of any action executed by M10. For instance, if M10 was told to search online or call an API, the result (success/failure and data) comes back to M09. M09 then decides the next step based on that outcome (e.g., if success, proceed; if failure, maybe adjust plan or ask user).
 - Additionally, M09 implicitly has access to context like active goal from M06 (which could be considered in decisions like when to end).

OUTPUTS:
 - **Chosen_Action:** This indicates what the Decision Engine has decided to do at a particular moment. It could be:
   - A command for M10 to perform a tool/external action (like “execute web search for X” or “send output to user”).
   - A command for M08 to perform reasoning (like “analyze data Y”).
   - Or a decision to finalize the task (like “goal complete, no further action”).
   This output often triggers the respective module via orchestrator (e.g., if it’s an external action, M10 will be invoked; if it’s an answer to user, M14 will be invoked).
 - **Next_Step_Command:** If following a plan, this is the specific step being executed or, after finishing one step, the next one if any. For example, “Step 2: Summarize the information found” or “Proceed to next subtask”. It could be used to inform working memory or logging.
 - **Completion_Status:** When a goal or plan is finished (or aborted), M09 outputs a status:
   - Success (possibly along with any final data like “Answer ready”).
   - Failure (and reason, if known).
   - Need Replan (if something went wrong and a new plan is needed).
   This status is sent to M06 (Goal Management) via triggers or via orchestrator so that M06 can mark the goal done or take further action (like initiating a replan or next goal).

DETAILED_DECISION_LOGIC:
 1. **Initialize Execution** (on Plan_Available trigger):
    - When a new plan is received from M07, store it (likely in working memory via M05 or internally).
    - Set a pointer or index to the first step.
    - Optionally, output a confirmation like "Executing plan of N steps" (maybe logged for trace).
    - Immediately evaluate: Is the first step something requiring reasoning or direct action?
      - If the step is an internal thought (e.g., “Analyze options”), then the Chosen_Action would be to invoke M08 with the relevant query.
      - If the step is an external action (e.g., “Search for X”), then Chosen_Action is to call M10 with that command.
      - If the step is to communicate something to the user (rare as a first step, usually that’s the final step), then Chosen_Action would involve M14.
    - Output **Chosen_Action** accordingly and update **Next_Step_Command** (like "Step 1: ..." to indicate what we’re doing).
 2. **Iterative Loop**:
    - After performing a step, wait for results:
      - If it was a reasoning step, wait for **Inference_Result** from M08.
      - If an external action, wait for **External_Action_Result** from M10.
    - On receiving a result (Inference_Ready or Action_Feedback triggers):
      - Assess the result:
        * If the result is successful/completed what was needed for that step, mark that step as done.
        * If the result indicates failure or an unexpected outcome, decide how to handle:
            - Possibly modify some data and retry the step (if minor issue).
            - Or decide that the plan might need adjusting (set Completion_Status to "needs_replan" or push to reflection).
            - If user input needed (like the action required info that wasn’t there), possibly trigger a communication to ask user (this is a complex branch where M09 might create a sub-goal to clarify, but often M14 or M06 would handle re-engaging user).
      - If the step produced some data useful for next steps, ensure it’s stored in M05 (Working Memory). E.g., if M08 returned "User's flight options: A, B, C", put that in working memory for the next step "Choose best flight".
      - Increment the step pointer to the next step.
    - Check if there is a next step:
      - If yes, decide the next action similarly: reasoning vs external vs communication.
      - Output a new **Chosen_Action** for that step and corresponding **Next_Step_Command**.
      - Loop continues.
    - If no next step (we finished the last step):
      - Set **Completion_Status** to success. Possibly include any final result (like the answer or confirmation that the action completed).
      - Decide how to finalize:
         * If the final output needs to be communicated to the user, the last step might have already prepared it (or perhaps the plan’s final step is indeed "present result to user via M14"). In that case, one of the last actions would involve M14 to output.
         * If the final result is not yet sent to user, now is the time to do it. For example, the plan might produce an answer in working memory; M09 should now send it to Communication module (M14) to actually respond. This can be considered an implicit final step.
      - Inform M06 (Goal Management) of completion via **Completion_Status** output or via orchestrator triggering Task_Completed. This allows M06 to mark goal done and move on.
 3. **Safety & Alignment at Decision Point**:
    - Before executing any chosen action, consult Safety (M11) if needed:
      - Particularly for external actions: verify with M11 if this action is allowed (M11 might have a function to call or we have guidelines).
      - For content to user: ensure it’s safe (though M14 will also check).
      - If M11 vetoes an action, M09 should either:
         * Skip that step or modify plan (maybe go to alternate step if available).
         * Or abort and mark failure if it can’t proceed safely.
      - E.g., if the plan said “Scrape website for data” and M11 says disallowed, M09 could decide to go to a backup: maybe ask the user for info or use an alternate approach (if known). If not, then fail gracefully.
    - This makes M09 a critical gatekeeper for safety as well, hence Safety_Level: High.
    - Also ensure that any decision that might violate user’s intention (like a surprising action not asked for) is double-checked. M09 should ideally only do actions that were part of the plan or are logical given the user’s request.
 4. **Adaptation and Reflection Trigger**:
    - If something goes significantly wrong (plan fails, or outcome is unsatisfactory), M09 should wrap up the current attempt and signal for adaptation:
      - Set Completion_Status to "failed" or "incomplete".
      - Possibly feed data to Reflection (M12) or Learning (M13) by summarizing what happened (though that might happen automatically if those modules monitor tasks).
      - Example: If after several steps, the answer we got doesn’t make sense, M09 might conclude “I cannot complete this with the given plan” and abort. M12 would then analyze why.
    - M09 itself doesn’t do the reflecting; it just stops or flags the need.
    - If user interrupts mid-plan with a new request, M09 should pause or abort current execution, output current status, and defer to M06’s new goal. (This scenario is managed by M06 switching goals, but M09 might need to safely stop ordering actions when it notices a higher-priority input; orchestrator likely resets the loop).

RECURSION_CHECKS:
 - M09 doesn’t call itself recursively, but it is inherently in a loop stepping through a plan.
 - Ensure that if a step requires multiple reasoning sub-steps, it’s M09 that orchestrates them one by one, rather than telling M08 to loop. For instance, if a plan step is "Find X and then calculate Y", better break that into two steps at planning stage, or within one step call M08 for X, get result, then call M08 for Y. But that’s two calls from M09, which is fine.
 - Avoid infinite loops:
    - If plan has a loop (e.g., "while not found, try again"), M09 should have an iteration limit or a condition to break (maybe via reflection or an explicit count). Our current plan design doesn’t include explicit loops, but just in case.
    - If no plan is present (like for simple actions), M09 should handle it gracefully (just treat it as a one-step plan essentially).
 - M09’s design assumes tasks eventually complete or fail; it should not get stuck waiting on something that won’t arrive (like waiting on an external action that is hung—though that is more on M10’s side to handle timeouts).

CHANGE_INSTRUCTIONS:
 - **Plan revision on the fly**: Currently, M09 executes a given plan. If you want M09 to have the capability to change the plan mid-way (for example, if it sees an easier path), you could implement that. It might involve:
    - Recognizing a scenario for replan (like "Step 3 not needed because we already got answer in step 2").
    - Skipping steps or jumping to another step out of sequence. If doing so, update `Next_Step_Command` and ensure no needed data is missed.
    - Or even calling M07 again for a sub-plan. (This complicates flow, but might be done if something unexpected comes up).
    - If implementing, be careful to avoid chaos; prefer sticking to plan unless a clear reason.
 - **Parallel execution**: If some steps could be done in parallel and you've allowed that in plan (rare in sequential flow), M09 by default is sequential. Introducing parallelism means handling multiple chosen actions at once which is a big change. Likely not needed unless the system becomes multi-threaded.
 - **More explicit safety gating**: If needed, integrate direct calls to M11 for each action. For instance, before sending any command to M10 or output to user, call a function of M11. You might already inherently rely on M11’s monitoring, but explicit checks can add safety. If doing so, add that in dependencies/triggers (like "Action_Approval_Request").
 - **User confirmation**: In some sensitive decisions, M09 could decide to ask the user for confirmation. For example, "Should I go ahead and book the flight?" If implementing such a feature:
    - It would output a special Chosen_Action to M14 to ask user.
    - Then wait for user input (which comes as new goal presumably).
    - This becomes a more complex dialogue management. Only implement if needed and then coordinate with M06 so that new goal "confirm Y/N" is handled.
 - **Final answer assembly**: If you want M09 to gather pieces of result and have M14 present them nicely, ensure that either the final plan step does it or M09 at completion sends a structured result to M14. Right now, likely the plan itself will include a step "present answer," but if not, M09 can handle by taking the inference result or data and calling M14 with it.
 - **Logging and transparency**: You can have M09 produce more verbose output or logging of each decision and why (perhaps feeding to supporting analysis for reflection). E.g., outputting "Chose to do X because Y." This can be captured in M12 later.
 - After any modifications, increment **Version** and update **Checksum**. If any new output types are added or format changed, update accordingly (and the receiving modules M10, M06, M14 if they parse them).
 - Test thoroughly when modifying M09, as it's central to proper flow.

---
Next_Suggest: M10_Action_Execution
Alternate_Next: M14_Communication (if finalizing output to user)
Resource_Usage: Moderate (runs throughout task, but logic operations are light; however, high safety critical)
---